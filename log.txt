{
TODO (1)
-id_to_ex_bus 在模拟波形中的后八位出现X态
--根据16进制指令，找到id_to_ex_bus后8位对应rdata2
---rdata2未初始化，在regfile.v中的rdata值是输出线，将当前模块返回到顶层模块中（这里是ID段）
----又发现根据 regfile.v 中 reg_array[raddr2] 这个代码，未能将值给到rdata2，说明当前寄存器未初始化，上一条指令还没有写入到寄存器中
-----在波形图中发现出现了数据相关问题，即ori操作在ex阶段时还未写入值到寄存器中，发现问题

                                
-数据相关：
--相邻指令间存在数据相关（ID、EX间存在数据相关）
--相隔一条指令的指令间存在数据相关（ID、MEM间存在数据相关）
--相隔两条指令的指令间存在数据相关（ID、WB间存在数据相关）

-添加数据前推通路：
--将EX段和MEM段引出一条通路连回ID段，传输数据参考WB段，同时在mycpu_core.v中增加相应的线路，这里用 ex(mem)_to_id_bus
---在ID段中继续参考WB段进行数据的接收，接下来应该处理对数据的处理，解决数据相关问题
----判断在EX，MEM，WB 段中是否出现和当前ID段需要访问的寄存器地址相等的情况，同时增加临时变量tdata1(2)，若有数据相关问题，赋值给tdata，代替rdata

TODO (2)
-继续添加部分指令，此时遇到 lw，sw 读写内存数据有问题
--应当增加 EX、MEM 中有关sram的功能
---这里的指令按照流水线一级一级传递，在每个周期内同步指令，应采用时序逻辑

-ID 段将指令传递给 EX 段
--EX 段接收，计算内存相关的操作:
---data_sram_wdata 传给顶层模块写入内存
---data_sram_addr  传给顶层模块写入内存
---data_sram_wen   传给顶层模块写入内存
---data_sram_en    传给顶层模块写入内存
---data_ram_sel    只在EX 段中出现，MEM 段中的data_ram_sel未定义,但是功能和data_ram_wen相同,在EX 段中将data_ram_wen同步为data_sram_wen
----由上分析，MEM 段似乎不需要增加其他连线,只需增加ID -> EX 间的关于读写内存指令的操作即可
-----通过一个点8'd1

-EX 段中的data_ram_en和data_ram_wen 出现 X 态
--这里先将内存操作位数传到EX和MEM段
---同时找到有关load的数据相关问题，准备进行处理
----书7.5节有关暂停机制讲解,在EX段中判断是否是load，并传回ID段，判断ID段的当前指令是否是出现load相关
-----EX段中应将load的信号传给ID段，ID段接受，并判断两个寄存器是否与前一条指令的写回地址相同（前面已经完成了数据前移操作）
-----因此在ID段中可以加入暂停操作
------加入后发现load的下一条指令的ID指令被修改,可能需要增加延迟槽进行管理, 又进一步修改数据迁移操作的相关指令后,通过8'd3

-根据波形图从头溯源,发现beq有问题（痛苦的过程）
-先找到当前汇编段的起点，发现当执行beq指令时，无法正确判断是否相等，根据书中的指令描述，发现一些指令设置错误
--经过重重调试，发现问题出在jalr这条指令，先将其注释掉，可以通过8'd12
---接着修改，增加inst_j指令后通过8'd15
----andi指令和xori指令未标识是否写入寄存器。。。修改后通过8'd36

-在实现bgezal等指令时，需要进行ALU计算，将当前的PC值加8写回到31号寄存器中，因此在修改时需要修改ALU部分
--添加了这一部分指令，进行debug，可以通过38点，发现blez指令有问题
---通过42点，jalr指令有问题,没进行PC+8的加法处理
----通过43点，接下来可能要准备增加hi，lo寄存器来计算乘除法

-因为在乘除法计算中，两个32位的数相乘结果为64位，而除法的时候，除了商以外，还存在余数
-因此为了避免32位通用寄存器存不下这些数的问题，MIPS架构使用了额外的HI、LO寄存器来完成乘除法运算

-思考:
--我需要从ID段得到移动指令,进而根据移动指令的具体移动要求完成操作
---mf**指令需要将hi lo写入寄存器rd中，因此我要在ID段中将这两条指令加入到 写入rd 中，rf_wb定为1, 同时需要在ID段中将mf**指令传给EX段
---EX中判断是否进行mf**操作，如果是的话，需要将hi lo寄存器的值作为ex_result，写回寄存器rd，因此需要将hi lo的值在ID段传给EX段
---然后EX段将结果传给MEM段，MEM到WB再写回HILO寄存器

---mt**指令需要从寄存器rs写入hi lo寄存器，因此需要在ID段中将rs作为操作数，我可以轻松得到rs寄存器中的值
---那么如果我在ID段中实现一个HILO_REG的模块例化，就可以在ID段直接将rs写入hi lo
---这样满足mf**和mt**的指令

---在EX段中发现，需要判断乘除法是否是有符号，因此从ID段传送的数据应该包括：
---inst_mfhi, inst_mflo, inst_mthi, inst_mtlo, mul_sign, div_sign, hi_val, lo_val 70位
---还应增加乘除法的表示 inst_mul, inst_div 共72位
---sign == 1 : 有符号

---ID 段实现HILO寄存器的模块例化: hi_in 和 lo_in 需要将EX段中的

---写回寄存器需要在WB段进行，若出现数据相关，需要将值从EX段返回至ID段进行判断

----综上：
----ID段中得到有关HILO寄存器的指令
----对于mflo mfhi两条指令，需要将hi lo的值在ID段读入并传送到EX段，并写回通用寄存器中，此时就需要将ex_result表示为hi lo的值
----在EX中进行乘除法操作时，将乘法的高32为写入hi，低32位写入lo，除法将余数写入hi，将商写入lo，这时就出现了数据相关问题，需要将此时
----计算的结果传回到ID段，确保ID段得到最新的值

----对于mtlo mthi两条指令，在ID段取得rs寄存器的值，

}



